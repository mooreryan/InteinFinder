open! Core
module Sh = Shexp_process

module Makeprofiledb = struct
  module Out = struct
    [@@@coverage off]

    type t = {db: string; log: string} [@@deriving fields, sexp]

    [@@@coverage on]

    let v ~db ~log = {db; log}
  end

  let with_smp_file ~(smp_files : Smp_files.t) ~f =
    let smp_files = (smp_files :> string list) in
    Utils.with_temp_file (fun file ->
        (* [write_lines] will flush the buffer. *)

        (* Write the list of smp file names to a single file. This file will be
           the input to rpsblast makeprofiledb command. *)
        Out_channel.write_lines file smp_files ;
        f file )

  (* It takes a file that lists all the smp paths explicitly. *)
  let run ~exe ~(smp_files : Smp_files.t) ~out_dir ~log_base =
    let out = out_dir ^/ "rpsblast_db" in
    let log = Utils.log_name ~log_base ~desc:"makeprofiledb" in
    let run in_ = Sh.run exe ["-in"; in_; "-out"; out] in
    let sh file = Utils.eval_sh log @@ run file in
    with_smp_file ~smp_files ~f:sh ;
    Out.v ~db:out ~log
end

module Search = struct
  let rpsblast_proc ~exe ~query ~target_db ~out ~evalue ~log =
    Sh.outputs_to ~append:() log
    @@ Sh.run
         exe
         [ "-query"
         ; query
         ; "-db"
         ; target_db
         ; "-num_threads"
         ; "1"
         ; "-outfmt"
         ; "6"
         ; "-out"
         ; out
         ; "-evalue"
         ; Utils.float_to_string_hum evalue ]

  let cat_files files out =
    let write_lines oc ic =
      (* These can be pretty big, so we avoid reading it all into memory. *)
      In_channel.iter_lines ic ~f:(fun line ->
          Out_channel.output_string oc (line ^ "\n") )
    in
    let cat oc file = In_channel.with_file file ~f:(write_lines oc) in
    Out_channel.with_file out ~f:(fun oc -> List.iter files ~f:(cat oc))

  let gen_procs ~exe ~query_files ~target_db ~evalue ~log =
    let tmp_out_files, procs =
      List.fold
        query_files
        ~init:([], [])
        ~f:(fun (tmp_out_files, procs) query ->
          let tmp_out = query ^ ".tmp_btab" in
          let proc =
            rpsblast_proc ~exe ~query ~target_db ~out:tmp_out ~evalue ~log
          in
          (tmp_out :: tmp_out_files, proc :: procs) )
    in
    (List.rev tmp_out_files, List.rev procs)

  let remove_files files =
    let remove_if_exists file =
      if Sys_unix.file_exists_exn file then Sys_unix.remove file
    in
    List.iter files ~f:remove_if_exists

  module Out = struct
    [@@@coverage off]

    type t = {out: string; log: string} [@@deriving fields, sexp]

    [@@@coverage on]

    let v ~out ~log = {out; log}
  end

  let assert_files_exist paths =
    List.map paths ~f:(fun path ->
        let exists = Sys_unix.file_exists_exn path in
        if exists then Or_error.return ()
        else
          Or_error.error_string
            [%string "SMP file '%{path}' was listed, but it does not exist."] )
    |> Or_error.all_unit |> Or_error.ok_exn

  (** Run all the rpsblast jobs in parallel, one for each query file. *)
  let run ~exe ~query_files ~target_db ~out_dir ~evalue ~log_base =
    let out = Out_file_name.rpsblast_search_out out_dir in
    let log = Utils.log_name ~log_base ~desc:"parallel_rpsblast" in
    (* Should never fail as the query_files will be generated by the
       InteinFinder pipeline. If it does, then you've got problems. *)
    assert_files_exist query_files ;
    let tmp_out_files, procs =
      gen_procs ~exe ~query_files ~target_db ~evalue ~log
    in
    Utils.eval_sh log @@ Sh.fork_all_unit procs ;
    cat_files tmp_out_files out ;
    remove_files tmp_out_files ;
    Out.v ~out ~log
end
